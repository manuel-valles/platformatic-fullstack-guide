// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}
// The additional parameters you want to pass to the `fetch` instance.
let defaultFetchParams = {}
const defaultJsonType = { 'Content-type': 'application/json; charset=utf-8' }

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./next-client-types.d.ts').NextClient['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./next-client-types.d.ts').NextClient['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

/**  @type {import('./next-client-types.d.ts').NextClient['setDefaultFetchParams']} */
export const setDefaultFetchParams = (fetchParams) => { defaultFetchParams = fetchParams }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _moviesApiGetMovies (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.ilike', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.id', 'orderby.title']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/movies/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetMovies']} */
export const moviesApiGetMovies = async (request) => {
  return await _moviesApiGetMovies(baseUrl, request)
}
async function _moviesApiCreateMovie (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/movies/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiCreateMovie']} */
export const moviesApiCreateMovie = async (request) => {
  return await _moviesApiCreateMovie(baseUrl, request)
}
async function _moviesApiUpdateMovies (url, request) {
  const queryParameters = ['fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.ilike', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/movies/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiUpdateMovies']} */
export const moviesApiUpdateMovies = async (request) => {
  return await _moviesApiUpdateMovies(baseUrl, request)
}
async function _moviesApiGetMovieById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetMovieById']} */
export const moviesApiGetMovieById = async (request) => {
  return await _moviesApiGetMovieById(baseUrl, request)
}
async function _moviesApiUpdateMovie (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiUpdateMovie']} */
export const moviesApiUpdateMovie = async (request) => {
  return await _moviesApiUpdateMovie(baseUrl, request)
}
async function _moviesApiDeleteMovies (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiDeleteMovies']} */
export const moviesApiDeleteMovies = async (request) => {
  return await _moviesApiDeleteMovies(baseUrl, request)
}
async function _moviesApiGetQuotesForMovie (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/movies/${request['id']}/quotes?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetQuotesForMovie']} */
export const moviesApiGetQuotesForMovie = async (request) => {
  return await _moviesApiGetQuotesForMovie(baseUrl, request)
}
async function _moviesApiGetQuotes (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.likes.eq', 'where.likes.neq', 'where.likes.gt', 'where.likes.gte', 'where.likes.lt', 'where.likes.lte', 'where.likes.like', 'where.likes.ilike', 'where.likes.in', 'where.likes.nin', 'where.likes.contains', 'where.likes.contained', 'where.likes.overlaps', 'where.movieId.eq', 'where.movieId.neq', 'where.movieId.gt', 'where.movieId.gte', 'where.movieId.lt', 'where.movieId.lte', 'where.movieId.like', 'where.movieId.ilike', 'where.movieId.in', 'where.movieId.nin', 'where.movieId.contains', 'where.movieId.contained', 'where.movieId.overlaps', 'where.quote.eq', 'where.quote.neq', 'where.quote.gt', 'where.quote.gte', 'where.quote.lt', 'where.quote.lte', 'where.quote.like', 'where.quote.ilike', 'where.quote.in', 'where.quote.nin', 'where.quote.contains', 'where.quote.contained', 'where.quote.overlaps', 'where.saidBy.eq', 'where.saidBy.neq', 'where.saidBy.gt', 'where.saidBy.gte', 'where.saidBy.lt', 'where.saidBy.lte', 'where.saidBy.like', 'where.saidBy.ilike', 'where.saidBy.in', 'where.saidBy.nin', 'where.saidBy.contains', 'where.saidBy.contained', 'where.saidBy.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.likes', 'orderby.movieId', 'orderby.quote', 'orderby.saidBy']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/quotes/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetQuotes']} */
export const moviesApiGetQuotes = async (request) => {
  return await _moviesApiGetQuotes(baseUrl, request)
}
async function _moviesApiCreateQuote (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/quotes/`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiCreateQuote']} */
export const moviesApiCreateQuote = async (request) => {
  return await _moviesApiCreateQuote(baseUrl, request)
}
async function _moviesApiUpdateQuotes (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.likes.eq', 'where.likes.neq', 'where.likes.gt', 'where.likes.gte', 'where.likes.lt', 'where.likes.lte', 'where.likes.like', 'where.likes.ilike', 'where.likes.in', 'where.likes.nin', 'where.likes.contains', 'where.likes.contained', 'where.likes.overlaps', 'where.movieId.eq', 'where.movieId.neq', 'where.movieId.gt', 'where.movieId.gte', 'where.movieId.lt', 'where.movieId.lte', 'where.movieId.like', 'where.movieId.ilike', 'where.movieId.in', 'where.movieId.nin', 'where.movieId.contains', 'where.movieId.contained', 'where.movieId.overlaps', 'where.quote.eq', 'where.quote.neq', 'where.quote.gt', 'where.quote.gte', 'where.quote.lt', 'where.quote.lte', 'where.quote.like', 'where.quote.ilike', 'where.quote.in', 'where.quote.nin', 'where.quote.contains', 'where.quote.contained', 'where.quote.overlaps', 'where.saidBy.eq', 'where.saidBy.neq', 'where.saidBy.gt', 'where.saidBy.gte', 'where.saidBy.lt', 'where.saidBy.lte', 'where.saidBy.like', 'where.saidBy.ilike', 'where.saidBy.in', 'where.saidBy.nin', 'where.saidBy.contains', 'where.saidBy.contained', 'where.saidBy.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/quotes/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiUpdateQuotes']} */
export const moviesApiUpdateQuotes = async (request) => {
  return await _moviesApiUpdateQuotes(baseUrl, request)
}
async function _moviesApiGetQuoteById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/quotes/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetQuoteById']} */
export const moviesApiGetQuoteById = async (request) => {
  return await _moviesApiGetQuoteById(baseUrl, request)
}
async function _moviesApiUpdateQuote (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/quotes/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiUpdateQuote']} */
export const moviesApiUpdateQuote = async (request) => {
  return await _moviesApiUpdateQuote(baseUrl, request)
}
async function _moviesApiDeleteQuotes (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/quotes/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiDeleteQuotes']} */
export const moviesApiDeleteQuotes = async (request) => {
  return await _moviesApiDeleteQuotes(baseUrl, request)
}
async function _moviesApiGetMovieForQuote (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/quotes/${request['id']}/movie?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./next-client-types.d.ts').NextClient['moviesApiGetMovieForQuote']} */
export const moviesApiGetMovieForQuote = async (request) => {
  return await _moviesApiGetMovieForQuote(baseUrl, request)
}
async function _postQuotesIdLike (url, request) {
  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData ? {} : defaultJsonType)
  }

  const response = await fetch(`${url}/quotes/${request['id']}/like`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./next-client-types.d.ts').NextClient['postQuotesIdLike']} */
export const postQuotesIdLike = async (request) => {
  return await _postQuotesIdLike(baseUrl, request)
}
async function _getExample (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/example`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./next-client-types.d.ts').NextClient['getExample']} */
export const getExample = async (request) => {
  return await _getExample(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    moviesApiGetMovies: _moviesApiGetMovies.bind(url, ...arguments),
    moviesApiCreateMovie: _moviesApiCreateMovie.bind(url, ...arguments),
    moviesApiUpdateMovies: _moviesApiUpdateMovies.bind(url, ...arguments),
    moviesApiGetMovieById: _moviesApiGetMovieById.bind(url, ...arguments),
    moviesApiUpdateMovie: _moviesApiUpdateMovie.bind(url, ...arguments),
    moviesApiDeleteMovies: _moviesApiDeleteMovies.bind(url, ...arguments),
    moviesApiGetQuotesForMovie: _moviesApiGetQuotesForMovie.bind(url, ...arguments),
    moviesApiGetQuotes: _moviesApiGetQuotes.bind(url, ...arguments),
    moviesApiCreateQuote: _moviesApiCreateQuote.bind(url, ...arguments),
    moviesApiUpdateQuotes: _moviesApiUpdateQuotes.bind(url, ...arguments),
    moviesApiGetQuoteById: _moviesApiGetQuoteById.bind(url, ...arguments),
    moviesApiUpdateQuote: _moviesApiUpdateQuote.bind(url, ...arguments),
    moviesApiDeleteQuotes: _moviesApiDeleteQuotes.bind(url, ...arguments),
    moviesApiGetMovieForQuote: _moviesApiGetMovieForQuote.bind(url, ...arguments),
    postQuotesIdLike: _postQuotesIdLike.bind(url, ...arguments),
    getExample: _getExample.bind(url, ...arguments)
  }
}